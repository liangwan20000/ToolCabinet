<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		img {
			width: 400px;
			height: 200px;
		}
	</style>
</head>
<body>
	<canvas id="canvas" width="150" height="150"></canvas>

	<script type="application/javascript">
	    function draw() {
	      	var canvas = document.getElementById("canvas");
	      	// 判断方法是否存在，检查canvas的支持性
	      	if (canvas.getContext) {
	      		// 取得canvas上下文
	      	  	var ctx = canvas.getContext("2d");

				// 正方形
	      		// ctx.fillRect(25, 25, 100, 100); // 绘制一个填充的矩形
			    // ctx.clearRect(45, 45, 60, 60); // 清除指定矩形区域，让清除部分完全透明。
			    // ctx.strokeRect(50, 50, 50, 50); // 绘制一个矩形的边框
			    
			    // 三角形
			    // ctx.beginPath(); // 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。
			    // ctx.moveTo(75, 50); // 移动起始点
			    // ctx.lineTo(100, 75); // 设置终点
			    // ctx.lineTo(100, 25); // 设置终点
			    // ctx.fill(); // 通过填充路径的内容区域生成实心的图形。
			    
			    // 笑脸
			    // ctx.beginPath();
			    // ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // 绘制
			    // ctx.moveTo(110, 75); // 设置起始点
			    // ctx.arc(75, 75, 35, 0, Math.PI, false);   // 口(顺时针)
			    // ctx.moveTo(65, 65); // 设置起始点
			    // ctx.arc(60, 65, 5, 0, Math.PI * 2, true);  // 左眼
			    // ctx.moveTo(95, 65); // 设置起始点
			    // ctx.arc(90, 65, 5, 0, Math.PI * 2, true);  // 右眼
			    // ctx.stroke(); // 通过线条来绘制图形轮廓。
			    
			    // 填充三角形
				// ctx.beginPath();
				// ctx.moveTo(25, 25);
				// ctx.lineTo(105, 25);
				// ctx.lineTo(25, 105);
				// ctx.fill();
				// // 描边三角形
				// ctx.beginPath();
				// ctx.moveTo(125, 125);
				// ctx.lineTo(125, 45);
				// ctx.lineTo(45, 125);
				// ctx.closePath(); // 闭合路径之后图形绘制命令又重新指向到上下文中。
				// ctx.stroke();

				// for(var i = 0; i < 4; i++){
				//     for(var j = 0; j < 3; j++){
				//     	ctx.beginPath();
				//     	var x = 25 + j * 50; // x 坐标值
				//     	var y = 25 + i * 50; // y 坐标值
				//     	var radius = 20; // 圆弧半径
				//     	var startAngle = 0; // 开始点
				//     	var endAngle = Math.PI + (Math.PI * j) / 2; // 结束点
				//     	var anticlockwise = i % 2 == 0 ? false : true; // 顺时针或逆时针
				//     	// x,y确定圆心，radius确定半径
				// 		ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);

				// 		if (i>1){
				// 			ctx.fill();
				// 		} else {
				// 			ctx.stroke();
				// 		}
				// 	}
				// }
				// 二次贝塞尔曲线
			    // ctx.beginPath();
			    // ctx.moveTo(75, 25);
			    // ctx.quadraticCurveTo(25, 25, 25, 62.5);
			    // ctx.quadraticCurveTo(25, 100, 50, 100);
			    // ctx.quadraticCurveTo(50, 120, 30, 125);
			    // ctx.quadraticCurveTo(60, 120, 65, 100);
			    // ctx.quadraticCurveTo(125, 100, 125, 62.5);
			    // ctx.quadraticCurveTo(125, 25, 75, 25);
			    // ctx.stroke();

				//三次贝塞尔曲线
				// ctx.beginPath();
				// ctx.moveTo(75, 40);
				// ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);
				// ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
				// ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);
				// ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
				// ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
				// ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);
				// ctx.fill();


				roundedRect(ctx, 12, 12, 150, 150, 15);
				roundedRect(ctx, 19, 19, 150, 150, 9);
				roundedRect(ctx, 53, 53, 49, 33, 10);
				roundedRect(ctx, 53, 119, 49, 16, 6);
				roundedRect(ctx, 135, 53, 49, 33, 10);
				roundedRect(ctx, 135, 119, 25, 49, 10);

				ctx.beginPath();
				ctx.arc(37, 37, 13, Math.PI / 7, -Math.PI / 7, false);
				ctx.lineTo(31, 37);
				ctx.fill();

				for(var i = 0; i < 8; i++){
					ctx.fillRect(51 + i * 16, 35, 4, 4);
				}

				for(i = 0; i < 6; i++){
					ctx.fillRect(115, 51 + i * 16, 4, 4);
				}

				for(i = 0; i < 8; i++){
					ctx.fillRect(51 + i * 16, 99, 4, 4);
				}

				ctx.beginPath();
				ctx.moveTo(83, 116);
				ctx.lineTo(83, 102);
				ctx.bezierCurveTo(83, 94, 89, 88, 97, 88);
				ctx.bezierCurveTo(105, 88, 111, 94, 111, 102);
				ctx.lineTo(111, 116);
				ctx.lineTo(106.333, 111.333);
				ctx.lineTo(101.666, 116);
				ctx.lineTo(97, 111.333);
				ctx.lineTo(92.333, 116);
				ctx.lineTo(87.666, 111.333);
				ctx.lineTo(83, 116);
				ctx.fill();

				ctx.fillStyle = "white";
				ctx.beginPath();
				ctx.moveTo(91, 96);
				ctx.bezierCurveTo(88, 96, 87, 99, 87, 101);
				ctx.bezierCurveTo(87, 103, 88, 106, 91, 106);
				ctx.bezierCurveTo(94, 106, 95, 103, 95, 101);
				ctx.bezierCurveTo(95, 99, 94, 96, 91, 96);
				ctx.moveTo(103, 96);
				ctx.bezierCurveTo(100, 96, 99, 99, 99, 101);
				ctx.bezierCurveTo(99, 103, 100, 106, 103, 106);
				ctx.bezierCurveTo(106, 106, 107, 103, 107, 101);
				ctx.bezierCurveTo(107, 99, 106, 96, 103, 96);
				ctx.fill();

				ctx.fillStyle = "black";
				ctx.beginPath();
				ctx.arc(101, 102, 2, 0, Math.PI * 2, true);
				ctx.fill();

				ctx.beginPath();
				ctx.arc(89, 102, 2, 0, Math.PI * 2, true);
				ctx.fill();
	      	}
	    }
	    // 封装的一个用于绘制圆角矩形的函数.
		function roundedRect(ctx, x, y, width, height, radius){
			ctx.beginPath();
			ctx.moveTo(x, y + radius);
			ctx.lineTo(x, y + height - radius);
			ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
			ctx.lineTo(x + width - radius, y + height);
			ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
			ctx.lineTo(x + width, y + radius);
			ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
			ctx.lineTo(x + radius, y);
			ctx.quadraticCurveTo(x, y, x, y + radius);
			ctx.stroke();
		}
	    draw();
	</script>

	<!-- <canvas id="drawing" width="640" height="360" style="border: 10px solid #ccc"></canvas> -->
	<!-- <script>
		let drawing = document.getElementById('drawing');
		if (drawing.getContext) {
			let context = drawing.getContext('2d');
			// // 开始路径
			// context.beginPath();
			// // 绘制外圆 arc (x, y, radius, startAngle, endAngle, counterclockwise):以(x, y)为圆心绘制一条弧线，弧线半径为radius，起始和结束角度(用弧度表示)分别为startAngle和endAngle.最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false表示按顺时针方向计算
			// context.arc(100, 100, 60, 0, 2 * Math.PI, false);
			// // 绘制内圆
			// // context.moveTo(194, 100);
			// context.arc(100, 100, 54, 0, 2 * Math.PI, false);
			// // 绘制分针
			// context.moveTo(100, 100);
			// context.lineTo(100, 60);
			// // 绘制时针
			// context.moveTo(100, 100);
			// context.lineTo(75, 100);
			// // 描边路径
			// context.stroke();

			// context.font = 'bold 14px Arial';
			// context.textAlign = 'center';
			// context.textBaseline = 'middle';
			// context.fillText('12', 100, 55)
			let fontSize = 100;
			context.font = fontSize + 'px Arial';

			while (context.measureText('hello world!').width > 140) {
				fontSize--;
				context.font = fontSize + 'px Arial';
			}

			context.fillText('hello world!', 10, 10);
			context.fillText('font size is' + fontSize + 'px', 10, 50);

			let imgURI = drawing.toDataURL('image/png');
			let image = document.createElement('img');
			image.src = imgURI;
			document.body.appendChild(image);
		}	
	</script> -->
	<!-- <script>
		let '使用前' {
			1： '要使用canvas元素，必须先设置其width和height属性，指定可以绘图的区域大小。如果浏览器不支持canvas元素，就会显示标签内的文字。',
			2： '<canvas id="drawing" width="640" height="360">A drawing of something.<canvas>',
			3： {
				'获取canvas元素'
				let drawing = document.getElementById('drawing'); 
				'确定浏览器支持canvas'
				if (drawing.getContext) {
					'取得2d上下文对象'
					let context = drawing.getContext('2d');
					'取得图像的数据URL;base64格式；来自不同的域会抛出错误'
					let imgUrl = drawing.toDataURL('image/png') // 第一个参数是图片格式 第二个参数是图片质量
				}
			},
			4: '2D上下文坐标开始于canvas元素的左上角，原点坐标是(0, 0),所有坐标值都基于这个原点计算'
		}
		let '填充、描边、绘制矩形' {
			'所有涉及描边和填充的操作都将使用这两个样式，直至重新设置这两个值。这两个属性的值也可以是渐变对象或模式对象': {
				fillStyle: '填充颜色',
				strokeStyle: '描边颜色',
			},
			'与矩形有关的方法'： {
				fillRect(x, y, width, height): '从(x, y)处开始绘制矩形;填充',
				strokeRect(x, y, width, height): '从(x, y)处开始绘制矩形;描边',
				clearRect(x, y, width, height): '从(x, y)处开始擦除矩形;挖掉一部分',
			}
		}
		let '绘制路径' {
			beginPath(): '表示开始绘制新路径，然会使用其他方法来实际地绘制路径',
			arc(x, y, radius, startAngle, endAngle, counterclockwise): '以(x, y)为圆心绘制一条弧线，弧线半径为radius，起始和结束角度(用弧度表示)分别为startAngle和endAngle.最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false表示按顺时针方向计算',
			arcTo(x1, y1, x2, y2, radius): '从上一点开始绘制一条曲线,到(x2, y2)为止,并且以给定的半径radius,穿过(x1, y1)',
			bezierCurveTo(c1x, c1y, c2x, c2y, x, y): '从上一点开始绘制一条曲线，到x,y为止，并且以(c1x, c1y)和(c2x, c2y)为控制点',
			lineTo(x, y): '从上一点开始绘制一条直线，到(x, y)为止',
			moveTo(x, y): '将绘图游标移动到(x, y), 不画线',
			quadraticCurveTo(cx, cy, x, y): '从上一点开始绘制一条二次曲线,到(x, y)为止,并且以(cx, cy)为控制点',
			rect(x, y, width, height): '从点(x, y)开始绘制一个矩形，这个方法绘制的是矩形路径',
			closePath(): '闭合路径，创建路径后，绘制一条连接到路径起点的线条',
			fill(): '路径完成，使用fillStyle填充',
			stroke(): '路径完成，使用strokeStyle描边',
			clip(): '在路径上创建一个剪切区域',
			isPointInPath(x, y): '在路劲关闭前，确定画布上的某一点是否位于路径上'
		}
		let '绘制文本' {
			'fillText()模仿了网页正常显示文本，使用的更多',
			fillText(text, x, y, pixelWidth): '要绘制的文本字符串，(x, y)坐标，最大像素宽度',
			strokeText(text, x, y, pixelWidth): '要绘制的文本字符串，(x, y)坐标，最大像素宽度',
			'上面这两个方法，都以下列3个属性为基础',
			font: '表示文本样式，大小和字体; bold 14px Arial;',
			textAlign: '表示文本对齐方式，值有 start、end、left、right、center;建议使用start和end;',
			textBaseLine: '表示文本的基线；值有 top、hanging、middle、alphabetic、ideographic、bottom',
			'这几个属性都有默认值不必每次都重新设置',
			measureText(text): '计算指定文本大小；参数是要绘制的文本，返回TextMetrics对象。返回的对象只有一个width属性。'
			let fontSize = 100
			context.font = fontSize + 'px Arial'
			while (context.measureText('hello world').width > 140) {
				fontSize--
				context.font = fontSize + 'px Arial'
			}
			context.fillText('hello world', 10, 10)
			context.fillText('font size is' + fontSize + 'px', 10, 50)
			'上面这段代码计算出了文字的大小'
		}
		let '变换' {
			rotate(angle): '围绕原点旋转图像angle弧度',
			scale(scaleX, scaleY): '缩放图像，在X方向乘以scaleX,在Y方向乘以scaleY。scaleX和scaleY的默认值都是1.0',
			translate(x, y): '将坐标原点移动到(x, y)。执行这个变换之后，坐标(0, 0)会变成之前由(x, y)表示的点。',
			transform(水平缩放, 水平倾斜, 垂直倾斜, 垂直缩放, 水平移动, 垂直移动): '直接修改变换矩阵',
			setTransform(水平缩放, 水平倾斜, 垂直倾斜, 垂直缩放, 水平移动, 垂直移动): '将上一个变换矩阵重置，然后再调用transForm',
			save(): '保存上下文的状态变化，调用方法后，所有设置会进入一个栈结构，得以妥善保管',
			restore(): '在保存设置的栈结构中向前返回一级，恢复之前的状态。',
			'连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可以一级一级返回。'
		}
		let '绘制图像' {
			drawImage(img或vdio或canvas, x, y, width, height, x1, y1, width1, height1): '绘制的图像元素，源图像X坐标，源图像Y坐标，源图像宽度，源图像高度，目标图像X坐标，目标图像Y坐标，目标图像宽度，目标图像高度'
		}
		let '阴影' {
			shadowColor: '用CSS颜色格式表示的阴影颜色，默认为黑色',
			shadowOffsetX: '形状或路径x轴方向的阴影偏移量，默认为0',
			shadowOffseTY: '形状或路径y轴方向的阴影偏移量，默认为0',
			shadowBlur: '模糊的像素数，默认0，既不模糊',
			'这些属性都可以通过context对象来修改，只要在绘制前为他们设置适当的值，就能产生阴影'
		}
		let '渐变' {
			createLinearGradient(startX, startY, endX, endY): '创建并返回CanvasGradient实例'
			addColorStop(色标位置, color): '色标位置是包括并介于0-1之间的数字'
			let gradient = context.createLinearGradient(30, 30, 70, 70)
			gradient.addColorStop(0, 'white')
			gradient.addColorStop(1, 'black')
			'绘制红色矩形'
			context.fillStyle = '#ff0000'
			context.fillRect(10, 10, 50, 50)
			'绘制渐变矩形'
			context.fillStyle = gradient
			context.fillRect(30, 30, 50, 50)
			'确保渐变与形状对齐'
			creatRectLinearGradient = (context, x, y, width, height) => {
				return context.createLinearGradient(x, y, x + width, y + height)
			}
			let gradient = createRctLinearGradient(context, 30, 30, 50, 50)
			gradient.addColorStop(0, 'white')
			gradient.addColorStop(1, 'black')
			'绘制渐变矩形'
			context.fillStyle = gradient
			context.fillRect(30, 30, 50, 50)
			createRectLinearGradient(startX, startY, startRadius, endX, endY, endRadius): '创建径向渐变和放射渐变'
			'可以把径向渐变想象成一个长圆桶，如果想从某个形状的中心点开始创建一个向外扩散的径向渐变效果，就要将两个圆定义为同心圆'
			let gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30)
			gradient.addColorStop(0, 'white')
			gradient.addColorStop(1, 'black')
			'绘制红色矩形'
			context.fillStyle = '#ff0000'
			context.fillRect(10, 10, 50, 50)
			'绘制渐变矩形'
			context.fillStyle = gradient
			context.fillRect(30, 30, 50, 50)
		}
		let '模式' {
			'模式其实就是重复的图像，可以用来填充或描边图形。'
			createPattern(img、video、canvas, string): 'img或video或canvas元素；第二个参数与CSS的backgrund-repeat属性值相同，包括 repeat、repeat-x、repeat-y、no-repeat'
			let img = document.images[0]
			pattern = context.createPattern(img, 'repeat')
			'绘制矩形'
			context.fillStyle = pattern
			context.fillRect(10, 10, 150, 150)
		}
		let '使用图像数据' {
			putImageData(imageData, x, y): '把图像数据绘制到画布上'
			getImageData(x, y, width, height): '取得原始图像数据；参数：要取得的画面区域的X和Y坐标以及该区域的像素宽度和高度。返回对象是ImageData的实例。'
			'ImageData对象都有三个属性：width、height、data。其中data属性是一个数组，保存着图像中每一个像素的数据。在data数组中，每一个像素用4个元素来保存，分别表示红、绿、蓝和透明度值。因此，第一个像素的数据就保存在数组的第0到第3个元素中，例如'
				let data = imageData.data
				red = data[0]
				green = data[1]
				blue = data[2]
				alpha = data[3]
			'数组中每个元素的值都包括并介于0到255之间。能够直接访问到原始图像数据，就能够以各种方式来操作这些数据。例如通过修改图像数据，可以像下面这样创建一个简单的灰阶过滤器。'
			let drawing = document.getElementById('drawing')
			'确定浏览器是否支持canvas'
			if (drawing.getContext) {
				let context = drawing.getContext('2d'),
					image = document.images[0],
					imageData, data, i, len, average, red, green, blue, alpha
				'绘制原始图像'
				context.drawing(image, 0, 0)
				'取得图像数据'
				imageData = context.getImageData(0, 0, image.width, image.height)
				data = imageData.data
				len = data.length
				for (i = 0; i < len; i += 4) {

					red = data[i]
					green = data[i + 1]
					blue = data[i + 2]
					alpha = data[i + 3]

					'求得rgb平均值'
					average = Math.floor((red + green + blue) / 3)

					'设置颜色值，透明度不变'
					data[i] = average
					data[i + 2] = average
					data[i + 3] = average
				}
				'写回图像数据，并显示结果'
				imageData.data = data
				context.putImageData(imageData, 0, 0)
			}
		}
		let '合成' {
			globalAlpha: '是一个包括并介于0-1之间的值，用于指定所有绘制的透明度。默认值为0。如果所有后续操作都要基于相同的透明度，就可以先把globalAlpha设置为适当值，然后绘制，最后再把他设置回默认值0；例子: 绘制蓝色矩形前设置 globalAlpha 为0.5，所以蓝色矩形呈现半透明效果，可以看到下面的红色矩形'
				'绘制红色矩形'
				context.fillStyle = '#ff0000'
				context.fillRect(10, 10, 50, 50)
				'修改全局透明度'
				context.globalAlpha = 0.5
				'绘制蓝色矩形'
				context.fillStyle = 'rgba(0, 0, 255, 1)'
				context.fillRect(30, 30, 50, 50)
				'重置全局透明度'
				context.globalAlpha = 0
			globalCompositeOperation: '表示后绘制的图形怎样与先绘制的图形结合。这个属性的值是字符串，可能的值如下：'
			source-over: '(默认值)后绘制的图形位于先绘制的图形上方。'
			source-in: '后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明'
			source-out: '后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明'
			source-atop: '后绘制的图形与先绘制的图形重叠的部分可见，先绘制的图形不受影响'
			destination-over: '后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见'
			destination-in: '后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明'
			destination-out: '后绘制的图形擦除与先绘制的图形重叠的部分'
			destination-atop: '后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明'
			lighter: '后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变量'
			copy: '后绘制的图形完全替代与之重叠的先绘制的图形'
			xor: '后绘制的图形与先绘制的图形重叠的部分执行 异或 操作'
			'例子'
				'绘制红色矩形'
				context.fillStyle = '#ff0000'
				context.fillRect(10, 10, 50, 50)
				'设置合成操作'
				context.globalCompositeOperation = 'destination-over'
				'绘制蓝色矩形'
				context.fillStyle = 'rgba(0, 0, 255, 1)'
				context.fillRect(30, 30, 50, 50)
		}
	</script> -->
</body>
</html>
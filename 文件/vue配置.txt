注册淘宝镜像	cnpm 完全可替代npm 
$ npm install -g cnpm --registry=https://registry.npm.taobao.org

全局安装脚手架  默认安装的最新版本 3.0+
npm i -g @vue/cli  

安装桥接工具 将2.0的功能补齐到目前的脚手架上
npm install -g @vue/cli-init

查看脚手架版本号
vue -V

采用 cli 2.0的特性 (生成简易模板)
$ vue init webpack-simple heroes

########################################################

删除 vue cli 保存的模板  在用户文件夹下 administrator下  .vuerc 文件

#########################################################

linkActiveClass: "active", // active为路由激活时动态添加的类，类名可以自定义

###############################################################################################################

给切换路由增加过渡效果 (扩展)

<transition name="slide">
     <router-view></router-view>
</transition>

#############################################################################################################

编写 过渡效果
.slide-enter,
.slide-leave-to {
opacity: 0;
}
.slide-enter-to,
.slide-leave {
opacity: 1;
}
.slide-enter-active {
transition: all 1s;
}

###############################################################################################################

创建一个项目
vue create demo

脚手架VueCLI-项目文件介绍

node_modules		// 项目需要的依赖包
public			// 静态资源存储目录
	index.html		// 项目主容器文件
	favicon.ico		// 项目默认索引图片
src
	assets			// 放置一些静态资源文件，例如图片、图标、字体 
	components		// 公共组件目录
	views			// 业务组件目录
	App.vue			// 顶层根基路由组件
	main.js			// 主入口文件
	router.js		// 路由配置文件
.editorconfig			// 代码规范配置文件
.eslintrc.js			// eslint代码规范检查配置文件
.gitignore			// git上传需要忽略的文件格式
babel.config.js			// babel配置文件
package-lock.json		// 依赖包版本锁定文件
package.json			// 项目基本信息配置文件
postcss.config.js		// css预处理器配置文件
vue.config.js			// webpack 配置文件(与webpack.config.js作用一致)

######################################################################################################################

脚手架VueCLI-简单配置

yarn serve	实时运行
yarn build	项目打包

引入 bootstarp的样式文件	根据错误 需要在webpack.config.js增加对不识别文件的处理

{
   test: /.(ttf|woff2|woff|eot)$/,
   loader: "file-loader",
   options: {
     name: "[name].[ext]?[hash]"
   }
}

########################################################################################################################

给项目做配置，在vue.config.js中进行

module.exports = {
    lintOnSave: true, // 在保存代码的时候开启eslint代码检查机制
    devServer: { // 实时保存/编译的配置段
        open: true, // 自动开启浏览器
        host: '127.0.0.1', // 服务主机名
        port: 12306 // 服务运行端口
    }
}

#############################################################################################################################

ESLint-应用

'semi': ['error', 'always'],      // 禁用限制分号
'no-multiple-empty-lines': ['error', {'max': 2 }],  // 空白行允许出现2个
'no-tabs': 'off',   // 不限制逗号后的空格
'indent': ['error', 4],     // 设置缩进为4个空格

###########################################################################################################################

给vscode安装扩展，名称为eslint,这个扩展可以对程序文件的代码做自动eslint规范修改优化操作

1. 给vscode编辑器安装扩展：VS Code ESLint extension


2. 安装全局的eslint依赖包
       npm install -g eslint
   该依赖包安装完毕是对1步骤扩展做支撑的


1. 打开vscode配置文件 settings.json  (by File-> Preferences->Settings)
   

在最末尾如下内容


"eslint.enable": true,
"eslint.autoFixOnSave": true,
"eslint.run": "onType",
"eslint.options": {
    "extensions": [".js",".vue"]
},
"eslint.validate": [
    { "language": "html", "autoFix": true },
    { "language": "javascript", "autoFix": true },
    { "language": "vue", "autoFix": true }
]

现在重启vscode编辑器,之后把项目服务开启 npm run serve

Ctrl+s： 保存编辑的文件后，会对vue文件做自动代码格式化操作，并且是遵守eslint规范的

#################################################################################################################################

npm i -g yarn			安装yarn

初始化package.js		yarn init -y

yarn add 依赖包名字    		安装

yarn remove element-ui		删除依赖

yarn upgrade			更新

yarn add axios vue-axios	同时下载多个

########################################################################################################################################

首页搭建-退出系统

<el-button @click="logout()">退出</el-button>  // 退出事件ok
<el-dropdown-item @click="logout()">退出</el-dropdown-item>   // 退出事件不ok

click事件一般是作用给普通的html标签身上的

,而上述第2种玩法，是把事件定义给组件了，显然事件不生效


解决：

给事件声明修饰器  native，使得该事件是针对内部的html标签生效

    

<el-dropdown-item @click.native="logout()">退出</el-dropdown-item>  // 事件ok




// 退出系统
    logout () {
      this.$confirm('确认要退出系统么?', '退出', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
      // 清除sessionStorage信息
        window.sessionStorage.clear()
        // 跳转到登录页面
        this.$router.push({ name: 'login' })
      }).catch(() => { })
    }
  }

##################################################################################################################################


文章被修改的离开提示

使用watch监听器完成

data(){
  return {
    xxx:222,  // 第一种监听情况
    cat:{name:'kitty',age:4,son:{nm:'black'}}  // 第二种监听情况
  }
}

watch:{
  xxx:function(newval,oldval){},  // 第一种监听情况   newval是新值  oldval是旧值

  cat:{  // 第二中监听情况监听cat对象
    handler:function(newval,oldval){}  // handler是固定写法
    deep:true  // 深层次监听  就是cat中嵌套的对象也能监听到
    immedlate: true  // 回调函数会在观察(data observer)开始后立即被调用
  },

  'cat.name':function(newval,oldval){}  // 针对某一个成员进行监听
}

################################

第三种情况控制监听的时机

vm是 vue对象,可以用this代替

vm对象.$watch('xxx',function(){})
vm对象.$watch('xxx', function(newval,oldval){}, {deep:true}) // 三个对象,1.监听对象;2.处理方法;3.设置深层次监听

    自定义方法
    methods: {

	监听页面是否变化方法   无缝跳转
        editFormWatch: function () {

            设置监听事件
            this.$watch('editForm', function () {

                如果页面数据发生变化,给editFormDirty赋值  editFormDirty在data中已创建
                this.editFormDirty = true;

                深层次监听
            }, { deep: true });
        }
#################################

vm.$nextTick()，作用就是修改的数据更新到页面之后才做后续处理事宜

this.$nextTick(() => {
    this.editFormWatch() // 数据更新到页面之后监听页面是否变化
})

##################################

离开当前路由的守卫
beforeRouteLeave (to, from, next) {

  离开页面前判断是否变化,变化就提示
  if (this.editFormDirty) {

    // 如果form表单被修改了，本身不保存，发生离开动作就要给与提示
    this.$confirm('当前表单已经被修改了，确认不保存要离开么?', '离开', {

        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
    }).then(() => {
        return next() // 放行
    }).catch(() => {
        return next(false) // 阻止执行
    })
  } else {
      return next() // 放行
  }
},

################################################################################################################################

















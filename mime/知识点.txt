1.v-model已经实现双向数据绑定了为什么还要watch?watch在什么时候用?computed在什么时候用? promise原理,哪些是异步哪些是同步?

	1.computed 对于任何复杂逻辑，你都应当使用计算属性。
		我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。
	然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。
	这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
	

	2.当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。
	使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

2.promise	常见的异步场景

- 接口调用
- 定时任务
- 事件函数


3.SVG和canvas怎么用

- 数据可视化（图表）
  - echarts
  - d3
  - threee.js(webgl)
- 动画
- 小游戏
- 特效


4.虚拟DOM是Vue和React的底层实现，本质上是通过对象的方式描述了真实的DOM

5.箭头函数如果函数体没有花括号，自带返回值

6.VUE通过 export default 导出的模块也是闭包，规则：模块之间定义相同的变量不冲突，运行时，不同的模块在不同的闭包环境中。

7.权限管理

8.短路表达式，做判断用：|| 找真，全是假时取后面的；&& 找假，全是真取后面的；

10.vue- $set:参数一，必须是data中的已经定义好的属性，并且值是对象；参数二子属性的子属性：新添加的属性名称；参数三：新添加的属性值

11.hash：指的是url中#之后的部分（锚点），用于定位页面的某一个位置；url地址的hash的变化不会导致浏览器发送新的请求；history相关api:

12.history：历史API；操作浏览器浏览历史的条目，方法一 pushState
：向历史记录中添加一个新的地址；方法二 replaceState
替换第一个历史记录；这两个方法有对应的监听方法

13.spa路由做的不是跳转，而是页面局部更新；ajax也是局部更新，请求完数据后更新页面的一部分，但是ajax不能回退；前端路由基于url地址的哈希（锚点）和 h5 history API;

14.路由基本使用：vue中需要挂载路由，router-link标签to跳转，route-view标签填充位；动态路由、编程式导航、嵌套路由、路由守卫、激活样式、asios拦截器拦截接口调用；路由传参与动态路由相关params，query,props

15.@keyup.enter:1.keyup当输入框改变时，调用设置的方法，pc端可用，移动端不支持，vue支持，mpvue不支持；keyup.enter是输入完成后必须回车才能触发设置的事件,enter是事件修饰符；事件参数中有keyCode参数，表示按了哪一个键的数字，

16.@confirm 当输入框改变时，调用设置的方法；

17.模块化就是把不同的业务逻辑放到不同的文件里，js的模块化是把特定的功能封装到特定的文件里，倒出时把特定的方法导出，不需要导出的方法只在模块内使用；模块之间不会干扰；

####################################################################################################################################################################

	React比较明显的体现了面向对象编程，它的每一个模块都是使用class类创建对象，当使用模块化导入后，通过jsx语法调用，这就面向对象了。

	class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法。

	React的jsx语法，是对js的扩展，使我们可以在js文件中写html标签，但是这个并不是真的html标签。jsx语法是通过React.creatElement（）创建一个虚拟dom对象，（虚拟dom就是对真实dom的描述对象，里面有标签名和属性等）。
	
	然后把所有的虚拟dom创建成真实的dom，再把所有真实的dom放入文档片断中，最后把文档片断一次性更新到页面。

